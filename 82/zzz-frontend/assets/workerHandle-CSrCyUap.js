var G=x=>{throw TypeError(x)};var H=(x,b,k)=>b.has(x)||G("Cannot "+k);var j=(x,b,k)=>(H(x,b,"read from private field"),k?k.call(x):b.get(x)),I=(x,b,k)=>b.has(x)?G("Cannot add the same private member more than once"):b instanceof WeakSet?b.add(x):b.set(x,k),w=(x,b,k,E)=>(H(x,b,"write to private field"),E?E.call(x,k):b.set(x,k),k);(function(){"use strict";var N,O,R,S,C;const x={};class b{constructor(){this.internal=new k}ref(e){return e.reduce((i,a)=>i.get(a),this.internal)}*[Symbol.iterator](){for(const[e,i]of this.internal.entries([]))"value"in i&&(yield[[...e],i.value])}*values(){for(const e of this.internal.allRefs())"value"in e&&(yield e.value)}}class k{constructor(){this.map=new Map}get(e){const i=this.map.get(e);if(i)return i;const a=new k;return this.map.set(e,a),a}*allRefs(){for(const e of this.map.values())yield*e.allRefs();yield this}*entries(e){const i=e.push(void 0)-1;for(const[a,n]of this.map.entries())e[i]=a,yield*n.entries(e);e.pop(),yield[e,this]}}function E(r){throw new Error(`Should not reach this with value ${r}`)}const Q={sum:r=>r.reduce((e,i)=>e+i,0),prod:r=>r.reduce((e,i)=>e*i,1),min:r=>Math.min(...r),max:r=>Math.max(...r),sumfrac:([r,e])=>r/(r+e),unique:([r])=>r},Y={match:([r,e])=>r===e?0:1,thres:([r,e])=>r>=e?0:1,lookup:([r],e)=>e[r]??0},_=Object.freeze([]),P=Object.freeze([]);function A(r){return{op:"const",x:_,br:P,ex:r}}const Z=(...r)=>W("sum",r),K=(...r)=>W("min",r),ee=(...r)=>W("max",r);function W(r,e){return{op:r,x:se(e),br:P}}function te(r,e){return{op:"read",x:_,br:P,tag:r,ex:e}}function se(r){return r.map(ne)}function ne(r){return typeof r=="number"||typeof r=="string"?A(r):r}function T(r,e){const i=new Map;function a(n){const c=i.get(n);if(c)return c;const u=n,s=q(n.x,a),m=q(n.br,a);(n.x!==s||n.br!==m)&&(n={...n,x:s,br:m});const t=e(n,u);return i.set(n,t),t}return q(r,a)}function z(r,e){const i=new Set;function a(n){i.has(n)||(e(n,a),i.add(n))}r.forEach(a)}function q(r,e){const i=r.map(e);return r.every((a,n)=>a===i[n])?r:i}function re(r,e,i){let a=`${e}=undefined`;for(const[c,u]of Object.entries(x))a+=`,${e}_${c}=${u.calc.toString()}`;const n=new Map;return z(r,(c,u)=>{const{op:s}=c;c.x.forEach(u),c.br.forEach(u);const m=c.x.map(f=>n.get(f)),t=c.br.map(f=>n.get(f)),o=`${e}${n.size}`;switch(n.set(c,o),a+=`,${o}=`,s){case"const":a+=typeof c.ex!="string"?c.ex:`'${c.ex}'`;break;case"sum":case"prod":m.length?a+=m.join(s=="sum"?"+":"*"):a+=s=="sum"?0:1;break;case"min":case"max":a+=`Math.${s}(${m})`;break;case"sumfrac":a+=`${m[0]}/(${m[0]}+${m[1]})`;break;case"match":a+=`${t[0]}===${t[1]}?${m[0]}:${m[1]}`;break;case"thres":a+=`${t[0]}>=${t[1]}?${m[0]}:${m[1]}`;break;case"read":{a+=`(${i(c)})`;break}case"subscript":a+=`${JSON.stringify(c.ex)}[${t[0]}]`;break;case"custom":a+=`${e}_${c.ex}([${m}])`;break;case"lookup":a+=`([${m}])[(${JSON.stringify(c.ex)})[${t[0]}]??0]`;break;default:E(s)}}),{str:a,names:n}}const X={arithmetic:Q,branching:Y},{arithmetic:J}=X;function oe(r){return r=ae(r),r=ie(r),r=ce(r),r}function ae(r){return T(r,e=>{const{op:i}=e;switch(i){case"sum":case"prod":case"min":case"max":if(e.x.length===1)return e.x[0];if(e.x.some(a=>a.op===i)){const a=e.x.flatMap(n=>n.op===i?n.x:[n]);return{...e,x:a}}}return e})}function ie(r){return T(r,e=>{const{op:i}=e;switch(i){case"sum":case"prod":case"min":case"max":{const a=e.x.filter(n=>n.op==="const");if(a.length>1){const n=e.x.filter(u=>u.op!=="const"),c=J[i](a.map(u=>u.ex));return c===J[i]([])?{...e,x:n}:{...e,x:[A(c),...n]}}}}return e})}function ce(r){const e=new Map,i=new b;return T(r,a=>{const{op:n}=a,c=a.x.map(t=>e.get(t)),u=a.br.map(t=>e.get(t));let s;switch(n){case"read":{const t=Object.keys(a.tag).sort();s=[n,a.ex,...t,...t.map(o=>a.tag[o])];break}case"sum":case"prod":case"min":case"max":s=[n,...c.sort()];break;case"thres":case"custom":case"sumfrac":case"lookup":case"subscript":case"const":s=[n,a.ex,...c,...u];break;case"match":s=[n,a.ex,...c,...u.sort()];break;default:E(n)}const m=i.ref(s);return"value"in m?m.value:(m.value=a,e.set(a,e.size),a)})}const{arithmetic:ue,branching:me}=X;function fe(r,e,i,a,n){const c=new le(r,a,e,i);for(;c.progress;)c.progress=!1,he(c),pe(c,1),ge(c),de(c,n);return c.nodes=oe(c.nodes),c}class le{constructor(e,i,a,n){I(this,N);I(this,O);I(this,R);I(this,S);I(this,C);this.progress=!0,w(this,N,e),this.minimum=i,w(this,O,a),this.cat=n}get nodes(){return j(this,N)}set nodes(e){j(this,N)!==e&&(this.progress=!0,w(this,N,e),w(this,S,w(this,C,void 0)))}get candidates(){return j(this,O)}set candidates(e){this.candidates!==e&&(this.progress=!0,w(this,O,e),w(this,R,w(this,S,w(this,C,void 0))))}get cndRanges(){return j(this,R)??w(this,R,this.candidates.map(B))}set cndRanges(e){w(this,R,e)}get nodeRanges(){return j(this,S)??w(this,S,L(this.nodes,this.cat,this.cndRanges))}get monotonicities(){return j(this,C)??w(this,C,xe(this.nodes.slice(0,this.minimum.length),this.cat,this.nodeRanges))}}N=new WeakMap,O=new WeakMap,R=new WeakMap,S=new WeakMap,C=new WeakMap;function he(r){const{nodes:e,nodeRanges:i}=r,a=T(e,(n,c)=>{const u=i.get(c);if(u.min===u.max)return c.op==="const"?n:A(u.min);switch(c.op){case"thres":{const[s,m]=c.br.map(t=>i.get(t));if(s.min>=m.max)return n.x[0];if(s.max<m.min)return n.x[1];break}case"min":{const s=n.x.filter((m,t)=>i.get(c.x[t]).min<=u.max);if(s.length===1)return s[0];if(s.length!==n.x.length)return K(...s);break}case"max":{const s=n.x.filter((m,t)=>i.get(c.x[t]).max>=u.min);if(s.length===1)return s[0];if(s.length!==n.x.length)return ee(...s);break}case"match":case"lookup":if(n.br.every(s=>s.op==="const")){const s=n.br.map(m=>m.ex);return n.x[me[c.op](s,c.ex)]}break;case"subscript":if(n.br[0].op==="const")return A(n.ex[n.br[0].ex]);break}return n});r.nodes=a}function pe(r,e){const{nodeRanges:i,minimum:a,cat:n}=r,c=[...r.candidates],u=[...r.cndRanges],s=[],m=[];let t=!1;if(r.nodes.forEach((f,l)=>{if(l<a.length){if(a[l]>i.get(f).min)t=!0;else if(l>=e)return;m.push(a[l])}s.push(f)}),m.length!=a.length&&(r.nodes=s,r.minimum=m),!t)return;let o=!1;c.forEach((f,l)=>{const h=u[l],p=f.filter(d=>{u[l]=B([d]);const y=L(s,n,u);return m.every((g,M)=>y.get(s[M]).max>=g)});p.length!=f.length?(c[l]=p,u[l]=B(p),o=!0):u[l]=h}),o&&(r.candidates=c,r.cndRanges=u)}function de(r,e){const i=[...r.monotonicities],a=r.candidates.map(t=>t.map(o=>{const f={incomp:[],inc:{},c:o};for(const[l,h]of i)h.inc?f.inc[l]=o[l]??0:h.dec?f.inc[l]=-(o[l]??0):f.incomp.push(o[l]??0);return f})),n=a[0][0];if(n===void 0)return;const c=Object.keys(n.inc),u=[...c].reverse(),s=!!n.incomp.length,m=a.map(t=>{const o=new b;return s?t.forEach(f=>{const l=o.ref(f.incomp);l.value?l.value.push(f):l.value=[f]}):o.ref([]).value=t,[...o.values()].flatMap(f=>(f.sort(({inc:l},{inc:h})=>{const p=u.find(d=>l[d]!==h[d]);return p===void 0?0:h[p]-l[p]}),f.filter(({inc:l},h)=>{let p=0;for(let d=0,y=h-e;d<=y+p;d++){const g=f[d].inc;if(c.every(M=>g[M]>=l[M])&&++p>=e)return!1}return!0})))});m.some((t,o)=>t.length!=r.candidates[o].length)&&(r.candidates=m.map(t=>t.map(o=>o.c)))}const v=Symbol();function ge(r){const{nodes:e,cat:i,candidates:a}=r,n=new Map;z(e,(t,o)=>{if(t.x.forEach(o),t.br.forEach(o),t.br.length)return;const f=t.x.map(h=>n.get(h));if(f.some(h=>!h))return;let l;switch(t.op){case"sum":{l={[v]:f.reduce((h,p)=>h+p[v],0)};for(const h of f)for(const[p,d]of Object.entries(h))l[p]=(l[p]??0)+d;break}case"prod":{const h=t.x.findIndex(d=>d.op!=="const");if(t.x.find((d,y)=>d.op!=="const"&&y!==h))return;l=h!==-1?{...f[h]}:{[v]:1};const p=f.reduce((d,y,g)=>g===h?d:d*y[v],1);p!=1&&(Object.keys(l).forEach(d=>l[d]*=p),l[v]*=p);break}case"read":l={[t.tag[i]]:1,[v]:0};break;case"const":if(typeof t.ex!="number")return;l={[v]:t.ex};break;default:return}n.set(t,l)});const c=new Map;if(z(e,(t,o)=>{const f=n.get(t);f&&Object.keys(f).length?c.set(t,f):(t.x.forEach(o),t.br.forEach(o))}),![...c.keys()].some(t=>{if(t.op==="const"||t.op==="read")return!1;if(t.op==="sum"&&t.x.length===2){if(t.x[0].op==="const"&&t.x[1].op==="read")return!1;if(t.x[1].op==="const"&&t.x[0].op==="read")return!1}return!0}))return;let s=new Map([...c.values()].map(t=>{const o=Object.keys(t).sort();return o.length===1&&t[o[0]]===1?[t,o[0]]:[t,""+o.flatMap(f=>[f,t[f]]).join("")]}));{const t=new Map([...s.values()].map((o,f)=>[o,`c${f}`]));s=new Map([...s].map(([o,f])=>[o,t.get(f)]))}const m=new Map;for(const[t,o]of s){const f=te({[i]:o});m.set(t,t[v]!==0?Z(t[v],f):f)}r.candidates=a.map(t=>t.map(o=>{const f={id:o.id};return s.forEach((l,h)=>{l in f||(f[l]=Object.entries(h).reduce((p,[d,y])=>p+(o[d]??0)*y,0))}),f})),r.nodes=T(e,(t,o)=>{const f=c.get(o);return f?m.get(f):t})}function B(r){const e=r.values(),i=e.next().value;if(!i)return{};const a=Object.fromEntries(Object.entries(i).map(([n,c])=>[n,{min:c,max:c}]));for(const n of e){for(const[c,u]of Object.entries(a)){const s=n[c]??0;u.min>s&&(u.min=s),u.max<s&&(u.max=s)}for(const[c,u]of Object.entries(n))c in a||(a[c]={min:Math.min(0,u),max:Math.max(0,u)})}return a}function L(r,e,i){const a=new Map;return z(r,(n,c)=>{n.x.forEach(c),n.br.forEach(c);const u=n.x.map(f=>a.get(f)),s=u.map(f=>f.min),m=u.map(f=>f.max);function t(f,[l,h]){const p=ue[f],d=[p([l.min,h.min]),p([l.min,h.max]),p([l.max,h.min]),p([l.max,h.max])];return{min:Math.min(...d),max:Math.max(...d)}}let o;switch(n.op){case"const":typeof n.ex=="number"?o={min:n.ex,max:n.ex}:o={min:NaN,max:NaN};break;case"sum":o={min:s.reduce((f,l)=>f+l,0),max:m.reduce((f,l)=>f+l,0)};break;case"prod":o={min:1,max:1},o=u.reduce((f,l)=>t(n.op,[f,l]),o);break;case"min":case"max":o={min:Math[n.op](...s),max:Math[n.op](...m)};break;case"match":case"thres":o={min:Math.min(...s),max:Math.max(...m)};break;case"sumfrac":s[0]+s[1]>0||m[0]+m[1]<0?o=t(n.op,u):o={min:NaN,max:NaN};break;case"read":{o={min:0,max:0};for(const{[n.tag[e]]:f}of i)f&&(o.min+=f.min,o.max+=f.max);break}case"subscript":{if(typeof n.ex[0]!="number")o={min:NaN,max:NaN};else{o={min:1/0,max:-1/0};let{min:f,max:l}=a.get(n.br[0]);f=Math.max(0,Math.ceil(f)),l=Math.min(l,n.ex.length-1);for(let h=f;h<=l;h++){const p=n.ex[h];o.min>p&&(o.min=p),o.max<p&&(o.max=p)}o.min>o.max&&(o={min:NaN,max:NaN})}break}case"lookup":isNaN(s[0])&&isNaN(m[0])&&(s.splice(0,1),m.splice(0,1)),o={min:Math.min(...s),max:Math.max(...m)};break;case"custom":o=x[n.ex].range(u);break;default:E(n)}a.set(n,o)}),a}function xe(r,e,i){const a=new Map,n=[],c=new Map;function u(s,m){a.has(s)||a.set(s,{inc:!0,dec:!0});const t=a.get(s);if(m&&t.dec)t.dec=!1;else if(!m&&t.inc)t.inc=!1;else return;n.push({node:s,inc:m})}for(r.forEach(s=>u(s,!0));n.length;){const{node:s,inc:m}=n.pop();switch(s.op){case"read":c.set(s.tag[e],a.get(s));break;case"const":break;case"sum":case"min":case"max":s.x.forEach(t=>u(t,m));break;case"thres":{s.x.forEach(f=>u(f,m));const t=i.get(s.x[0]),o=i.get(s.x[1]);t.max>o.min&&(u(s.br[0],m),u(s.br[1],!m)),t.min<o.max&&(u(s.br[0],!m),u(s.br[1],m));break}case"sumfrac":{const[t,o]=s.x.map(f=>i.get(f));o.min<0&&u(s.x[0],!m),o.max>0&&u(s.x[0],m),t.min<0&&u(s.x[1],m),t.max>0&&u(s.x[1],!m);break}case"prod":{const t=i.get(s);if(t.min<0&&t.max>0)s.x.forEach(o=>u(o,!0)),s.x.forEach(o=>u(o,!1));else{const o=m===t.max>0;s.x.forEach(f=>u(f,o===i.get(f).max>0))}break}case"match":case"lookup":s.x.forEach(t=>u(t,m)),s.br.forEach(t=>u(t,!0)),s.br.forEach(t=>u(t,!1));break;case"subscript":{const{br:[t],ex:o}=s;if(typeof o[0]=="number"){let{min:f,max:l}=i.get(t);f=Math.max(0,Math.ceil(f)),l=Math.min(l,o.length-1);for(let h=f+1;h<=l;h++)if(o[h-1]<o[h]){u(t,m);break}for(let h=f+1;h<=l;h++)if(o[h-1]>o[h]){u(t,!m);break}}else u(t,!0),u(t,!1);break}case"custom":x[s.ex].monotonicity(s.x.map(t=>i.get(t))).forEach((t,o)=>{t.inc||u(s.x[o],!m),t.dec||u(s.x[o],m)});break;default:E(s)}}return c}const U=2e6;function F(r){return r.reduce((e,i)=>e*i.length,1)}function be(r,e){const{progress:i,topN:a}=e;let{nodes:n,minimum:c,candidates:u}=r;const s=fe(n,u,"q",c,a);({nodes:n,minimum:c,candidates:u}=s);const{cndRanges:m,monotonicities:t}=s,o=F(u);return i.skipped+=r.count-o,i.remaining-=r.count-o,o?o<=U?{nodes:n,candidates:u,minimum:c,count:o}:ke(u,m,t).map(f=>{const l=F(f);return{nodes:n,candidates:f,minimum:c,count:l}}):[]}function ke(r,e,i){const a=[];for(const[n,c]of i)!c.inc&&!c.dec&&a.push(n);if(a.length)for(let n=0,c=e.length;n<c;n++){const u=e[n],s=a.find(t=>u[t]&&u[t].min!==u[t].max);if(s===void 0)continue;const m=new Map;for(const t of r[n]){const o=m.get(t[s]);o?o.push(t):m.set(t[s],[t])}return[...m.values()].sort((t,o)=>o.length-t.length).map(t=>D(t,n,r))}return we(r,i)}function we(r,e){const i=new Map;for(const[s,{inc:m,dec:t}]of e)m?i.set(s,Math.random()):t&&i.set(s,-Math.random());const a=r.reduce((s,m,t,o)=>o[s].length<m.length?t:s,0),n=r[a].map(s=>{const m=Object.entries(s).reduce((t,[o,f])=>typeof f=="number"?t+f*i.get(o):t,0);return[s,m]});n.sort((s,m)=>s[1]-m[1]);const c=Math.ceil(n.length/4),u=[];for(let s=0;s<n.length;s+=c){const m=n.slice(s,s+c).map(([t])=>t);u.push(D(m,a,r))}return u}function D(r,e,i){return i=[...i],i[e]=r,i}const $e=3e3;class ye{constructor(e){this.subworks=[],this.builds=[],this.progress={computed:0,failed:0,skipped:0,remaining:0},this.nodes=e.nodes,this.minimum=e.minimum,this.candidates=e.candidates.map(i=>new Map(i.map(a=>[a.id,a]))),this.topN=e.topN}add(e){const{subworks:i,progress:a,candidates:n}=this;e.forEach(c=>a.remaining+=c.count),i.unshift(...e.map(({ids:c,count:u})=>({nodes:this.nodes,minimum:this.minimum,candidates:c.map((s,m)=>s.map(t=>n[m].get(t))),count:u}))),i.length===e.length&&this.spreadSubworks()}steal(e){const{subworks:i,progress:a}=this;e=Math.floor(Math.max(e,U));let n=a.remaining-e;if(n<=0)return[];const c=i.findIndex(s=>(n-=s.count)<=0)+1,u=i.splice(0,c||i.length);return a.remaining=e+n,u.map(({candidates:s,count:m})=>({ids:s.map(t=>t.map(o=>o.id)),count:m}))}hasWork(){return!!this.subworks.length}compute(){const e=this.subworks.pop();if(!e)return;this.spreadSubworks();const{progress:i,topN:a}=this,{nodes:n,minimum:c,candidates:u,count:s}=e,m=Me(n,c,a,"q",u.length),{failed:t,results:o}=m(u,this.minimum[0]);i.computed+=s,i.failed+=t,i.remaining-=s,this.builds.push(...o)}setOptThreshold(e){this.minimum[0]=e,this.builds=this.builds.filter(i=>i.value>=e)}resetProgress(){const{progress:e,topN:i,builds:a,minimum:n}=this;a.sort((u,s)=>s.value-u.value).splice(i),a.length===i&&(n[0]=a[i-1].value);const c={builds:[...a],...e};return e.computed=0,e.failed=0,e.skipped=0,c}spreadSubworks(){const{subworks:e,minimum:i}=this;for(;e.length;){const a=e.pop();a.minimum[0]=i[0];const n=be(a,this);if(Array.isArray(n))e.push(...n);else{e.push(n);return}}}}function Me(r,e,i,a,n){const c=[...new Array(n)].map((g,M)=>M),u=c.map(g=>`cnds${g}`),s=c.map(g=>`c${g}`),{str:m,names:t}=re(r,"x",({tag:g})=>`+(${s.map(Ne=>`(${Ne}['${g[a]}']??0)`).join("+")}+0)`),o=r.map(g=>t.get(g)),f=e.map((g,M)=>!!M&&`${g}>${o[M]}`),l=s.map(g=>`${g}['id']`),h=`if(${$e}<out.length){
  out.sort((a,b)=>b.value-a.value).splice(${i})
  m=out[${i-1}].value
}`,p=c.map(g=>`for(const ${s[g]} of ${u[g]}){`),d=c.map(g=>g===1?"}"+h:"}"),y=`'use strict';
const[${u}]=candidates,out=[];let failed=0
${p.join("")}
  const ${m}
  if(${f.join("||")}){failed+=1;continue}
  if(m>${t.get(r[0])})continue
  out.push({ids:[${l}],value:${t.get(r[0])}})
${d.join("")}
return{failed,results:out}`;return new Function("candidates","m",y)}onmessage=async({data:r})=>{try{const e=await ve(r);e&&postMessage(e)}catch(e){postMessage({ty:"err",msg:`${e}`})}};let $;async function ve(r){switch(r.ty){case"init":if($)throw new Error("already initialized");return $=new ye(r),{ty:"progress",idle:!0,...$.resetProgress()};case"config":$.setOptThreshold(r.threshold);return;case"work?":{const e=$.steal(r.maxKeep);return e.length?{ty:"add",works:e}:void 0}case"add":return $.add(r.works),Ee()}}let V=!1;async function Ee(){if(V)return;V=!0;let r;do await new Promise(e=>setTimeout(e)),r=$.subworks.length<=1,postMessage({ty:"progress",idle:r,...$.resetProgress()}),$.compute();while($.hasWork());return V=!1,{ty:"progress",idle:!r,...$.resetProgress()}}})();
